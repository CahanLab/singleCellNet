---
title: "`SingleCellNet` Vignette"
author:
- name: Yuqi Tan
  affiliation: 
    - Johns Hopkins University School of Medicine, MD, USA
- name: Patrick Cahan
  affiliation: 
    - Johns Hopkins University School of Medicine, MD, USA
output: #rmarkdown::html_vignette
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE
)
```

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# Introduction

Traditionally, single cell annotation is based on the expression of cell type-specific markers, which obscures a quantitative assessment of the cell identity. Despite many attempts to address the issue, classification or cell annotation methods remain largely restricted in a platform-specific manner. Our computational tool, SingleCellNet (SCN), implements a Random Forest classifier to learn cell type-specific gene pairs from cross-platform and cross-species datasets and thus quantitatively assesses cell identity at a single-cell resolution. See the [our publication for more details](https://doi.org/10.1016/j.cels.2019.06.004).

This vignette demonstrate 1) Training 2) Query 3) Visualiztion features of SCN. If you want to use bulk RNAseq data, please go to [bulk CellNet](https://github.com/pcahan1/CellNet).  

# SCN input

## Load data

`SCN` provides utility functions to load in rda and loom file. To load rda file, users only need to provide the filenames that lead to sample table and expression matrix. To load loom file, users need to provide the path of the loom file, and specifies the annotation column needed as sample annotation.   

```{r, eval = FALSE}
# load rda file
sampTab <- utils_loadObject(fname)
expDat <- utils_loadObject(fname)
  
# load loom file
lfile <- loadLoomExpCluster(path , cellNameCol = "obs_names", xname = "cluster")
sampTab = lfile$sampTab
expDat = lfile$expDat
```

## Object conversion

Though the direct input for `SCN` is basic S3 class object, `SCN` incorporates utility functions to ease  the transition `SingleCellExperiment` object and `Seurat` object to `SCN` analysis. 

```{r, eval = FALSE}
#exp_type options can be: counts, data, and scale.data if they are available in your sce object
scefile <- extractSCE(sce_object, exp_slot_name = "counts") 
sampTab = scefile$sampTab
expDat = scefile$expDat

#exp_type options can be: counts, normcounts, and logcounts, if they are available in your sce object
seuratfile <- extractSeurat(seurat_object, exp_slot_name = "counts")
sampTab = seuratfile$sampTab
expDat = seuratfile$expDat
```

## Downloading the example data

In this vigenette, A subset of mouse Tabula Muris 10x data set [The Tabula Muris Consortium et al](https://www.nature.com/articles/s41586-018-0590-4) will be used as training data and a subset of human peripheral blood mononuclear cells (PBMC) 10x data set as query data [10x Genomics](https://support.10xgenomics.com/single-cell-gene-expression/datasets). You can also download the example datasets here: [training metadata](https://s3.amazonaws.com/cnobjects/singleCellNet/examples/sampTab_TM_053018.rda), [training expression matrix](https://s3.amazonaws.com/cnobjects/singleCellNet/examples/expTM_Raw_053018.rda) , [query metadata](https://s3.amazonaws.com/cnobjects/singleCellNet/examples/stDat_beads_mar22.rda), [query expression matrix](https://s3.amazonaws.com/cnobjects/singleCellNet/examples/6k_beadpurfied_raw.rda), [human-mouse orthologs](https://s3.amazonaws.com/cnobjects/singleCellNet/examples/human_mouse_genes_Jul_24_2018.rda).


# SCN Training

## Loading example data into R

```{r input,  message=FALSE}
library(singleCellNet)
```

```{r}
#loading training data
stTM <- utils_loadObject(fname = "../data/stTM_raw_060719_demo.rda") #metadata
expTMraw <- utils_loadObject(fname = "../data/expTM_raw_060719_demo.rda") #expression matrix

#loading query data
stQuery <- utils_loadObject(fname = "../data/stPBMC_demo.rda") #metadata
expQuery <- utils_loadObject(fname = "../data/expPBMC_demo.rda") #expression matrix
```

## Ortholog conversion for cross species analysis

Since training data is mouse scRNA-Seq data and query data is human scRNA-Seq data, we convert orthlogs between the two species using the ortholog table determined by by HCOP ( [Seal et al., 2011](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3013772/).) and subset the training data and query data by the genes that are common between them.
```{R, message= FALSE}
oTab <- utils_loadObject(fname = "../data/human_mouse_genes_Jul_24_2018.rda")

aa = csRenameOrth(expQuery = expQuery, expTrain = expTMraw, orthTable = oTab)
expQueryOrth <- aa[['expQuery']]
expTrainOrth <- aa[['expTrain']]
```

However, if your training data and query data are of the same specie, you can skip this ortholog conversion step and just subset the datasets based on common genes before proceeding to training.
```{r, eval = FALSE}
expTrain <- utils_loadObject(fname) #expression matrix
expQuery <- utils_loadObject(fname) 

commonGenes<-intersect(rownames(expTrain), rownames(expQuery))
expTrain <- expTrain[commonGenes, ]
expQuery <- expQuery[commonGenes, ]
```

## Training the data

We use the same number of cells per cell type, i.e. balanced data, to train Top-Pair Random Forest classifier. The remaining of the data or the held-out data will be used as validation data to evaluate the performance of the TP-RF classifier. Empirically we have found 50 cells to be a minimal cell number to create a classifier with good performance, however it may vary depend on the quality of your reference data, so it is really important to assess the performance of your classifier before proceeding to query your sample of interest.   

```{r, message = FALSE}
stList<-splitCommon(sampTab = stTM, ncells = 50, dLevel = "newAnn")
stTrain<-stList[[1]]
expTrain <- expTrainOrth[,stTrain$cell]

stTest <- stList[[2]]
expTest <- expTrainOrth[,stTest$cell]
```

This training step includes: 1) normalize and log-transform & scale the training data, 2) find top gene pairs and transform the training data into a binary matrix, 3) train the Top-pair Random Forest classifier

Firstly, it is important to have the traning data in its raw counts form prior to this normalization and transformation step. Variability in normalization and transformation methods can affect the performance of the classifier.

Once we have the properly normalized and transformed training expression matirx and metadata, we are ready to look for the topX number of most discriminating gene-pairs for each cell type. To be computational efficient, we start the gene-pairs search in the most differentially expressed genes. Then within that most differentially expressed genes, we search for the topX number of top gene-pairs or most discriminating gene-pairs within the subset of expression matrix of topX most differentially expressed genes. It is important to note that as the number of unique cell types within each training data set increases, the topX for both differential expressed genes and top gene-pairs should be increased accordingly. After we identified the topX gene-pairs, we use template matching to transform the training data into a binary matrix. 

After the training data binarized using the top gene-pairs, we use it to built a multi-class Random Forest classifier with 1000 trees. We create 50 randomized single cell profile by randomly permutating the expression matrix within the training data. The addition category in the multi-class Random Forest classifier serves as a "Garagbe Collector" so that query cells whose true cell identity is not contained in the training data set will not be coerced into the most similar cell type within the training.

```{r}
system.time(class_info<-scn_train(stTrain = stTrain, expTrain = expTrain, nTopGenes = 10, nRand = 70, nTrees = 1000, nTopGenePairs = 25, dLevel = "newAnn", colName_samp = "cell"))
```

## Assess the Top-pair Random Forest classifier with heldout data

After the building of Top-pair Random Forest (TP-RF) classifier, it is cruicial to assess its performance with its own heldout data or external dataset with known truth or well-annotated cell identiy. Here, we use the held-out data from the Tabula Muris dataset to assess the TP-RF classifer. We first template match the held-out data or the test data to binarize the test data according the top gene pairs selected above. Then we query or classify the test data set through the TP-RF classifier. After assessing it Precision-Recall curve, we can see almost all the performances of each category within the TP-RF classifier are near perfect (area under PR curve = 1).  Then we can confidently proceed to query data set of interest to the TP-RF classifier.
```{r}
#apply heldout data
system.time(classRes_val_all <- scn_predict(class_info[['cnProc']], expTest, nrand = 50))

#assessment
tm_heldoutassessment <- assess_comm(ct_scores = classRes_val_all, stTrain = stTrain, stQuery = stTest, dLevelSID = "cell", classTrain = "newAnn", classQuery = "newAnn")
plot_PRs(tm_heldoutassessment)
```

# SCN Query

## Apply human PBMC 10x query data

One of the kep features of TP-RF is that the classification step is robust to the normalization and transformation steps of the query data sets. One can even directly use raw data to query and still obtains accurate classification. Refer to [SCN manuscript](https://doi.org/10.1016/j.cels.2019.06.004) for more details on how cell cycle regression may affect your classification result. 

In this example, we binarize the human PBMC 10x raw query data by template matching it with the topX gene-pair selected from the previous steps. Then we classify the human PBMC 10x query data with the TP-RF classifier which showed favorable performance in the previous step. We create another 50 randomized single cell RNA-seq profiles which serve as positive controls that should be mostly classified as Rand or unknown category in the TP-RF classifer.

```{r}
system.time(crPBMC <- scn_predict(class_info[['cnProc']], expQueryOrth, nrand = 50))
```

# SCN Visualization

There are three major ways to visualize the classification output or the classification matrix. The first one is to visualize the result with a classification heatmpa. We create a vector of the labels for each cell in the query data. Here since we know the true idenity of each single cell, we use that as label. Most cases where the true identity of the query is unknown, clustering assignment will be used instead.

## Visualize the classification score with a heatmap
```{r}
#create labels for classification heatmap
sgrp<-as.vector(stQuery$description)
names(sgrp)<-rownames(stQuery)
grpRand<-rep("rand", 50)
names(grpRand)<-paste("rand_", 1:50, sep='')
sgrp<-append(sgrp, grpRand)

sc_hmClass(crPBMC, sgrp, max=5000, isBig=TRUE, cCol=F, font=8)
```

Second major visualization display for classification score is violin plot. Here we decide to lay out the violin plot horizontally by selecting the number of column in display to be the same number of the cell type, which is 8. This visualization is best to demonstrate the specificity of the classification method.

## Visualize the classification score with a violin plot

### Global view
```{r, warning=FALSE}
sc_violinClass(sampTab = stQuery,classRes = crPBMC, cellIDCol = "sample_name", dLevel = "description", ncol = 9)
```

### Selected cluster

To zoom into a specific cell type of interest, one can also restrict the display of classification score using sub_cluster parameter.
```{R}
sc_violinClass(sampTab = stQuery, classRes = crPBMC, cellIDCol = "sample_name", dLevel = "description", ncol = 9, sub_cluster = "B cell")
```


## Visualize the classification score with a attribution plot

The third major way of visualization is an attribution plot, which is best at displaying the composition of the cell types within clusters, tissues, organs, samples, and time points.
```{R}
plot_attr(sampTab = stQuery, classRes = crPBMC, nrand=50, sid="sample_name", dLevel="description")
```

## Visualize top pair gene expression

You can also visualize the average gene expression of Top pair genes in both query data and average expression in training data.
```{r}
gpTab <- compareGenePairs(query_exp = expQueryOrth, training_exp = expTrainOrth, training_st = stTrain, classCol = "newAnn", sampleCol = "cell", RF_classifier = class_info$cnProc$classifier, numPairs = 20, trainingOnly = FALSE)

sgrp<-as.vector(stQuery$prefix)
names(sgrp)<-rownames(stQuery)
train <- findAvgLabel(gpTab, stTrain = stTrain, dLevel = "newAnn")
sgrp <- append(sgrp, train)

hm_gpa_sel(gpTab, genes = class_info$cnProc$xpairs, grps = sgrp, maxPerGrp = 5)

```

# Session Information
```{r}
sessionInfo()
```



